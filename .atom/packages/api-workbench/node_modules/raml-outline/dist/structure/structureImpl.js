/// <reference path="../../typings/main.d.ts" />
"use strict";
exports.parser = require("raml-1-parser");
var _ = require("underscore");
var _labelProviders = [];
var _decorators = [];
var _categoryFilters = {};
var _visibilityFilter = null;
var _contentProvider = null;
var _astProvider = null;
var _keyProvider = null;
/**
 * Adds label provider. The system can contain several lable providers at once,
 * the first one returning a label will be used.
 * @param provider
 */
function addLabelProvider(provider) {
    _labelProviders.push(provider);
}
exports.addLabelProvider = addLabelProvider;
/**
 * Adds decorator. The system can contain severla decorators. The first one providing
 * data will be used.
 * @param decorator
 */
function addDecorator(decorator) {
    _decorators.push(decorator);
}
exports.addDecorator = addDecorator;
/**
 * Adds new category and its filter. Each category creates its own structure tree.
 * Several categories may contain the same node.
 * Adding the same category the second tie overrides the filter.
 * @param categoryFilter
 */
function addCategoryFilter(categoryName, categoryFilter) {
    _categoryFilters[categoryName] = categoryFilter;
}
exports.addCategoryFilter = addCategoryFilter;
/**
 * Sets global visibility filters. Nodes being rejected by the filter are not
 * going into the structure tree of any category.
 * @param visibilityFilter
 */
function setVisibilityFilter(visibilityFilter) {
    _visibilityFilter = visibilityFilter;
}
exports.setVisibilityFilter = setVisibilityFilter;
/**
 * Sets content provider. It is recommended to use the default one.
 * @param contentProvider
 */
function setContentProvider(contentProvider) {
    _contentProvider = contentProvider;
}
exports.setContentProvider = setContentProvider;
/**
 * Sets key provider. It is recommended to use the default one.
 * @param keyProvider
 */
function setKeyProvider(keyProvider) {
    _keyProvider = keyProvider;
}
exports.setKeyProvider = setKeyProvider;
/**
 * Sets AST provider. Must be called to use the module.
 */
function setASTProvider(astProvider) {
    _astProvider = astProvider;
}
exports.setASTProvider = setASTProvider;
var StructureNodeImpl = (function () {
    function StructureNodeImpl(hlSource) {
        this.hlSource = hlSource;
    }
    /**
     * Returns structure node source.
     */
    StructureNodeImpl.prototype.getSource = function () {
        return this.hlSource;
    };
    /**
     * Converts structure node and its children recursively into JSON, containing
     * text, icon and children fields.
     */
    StructureNodeImpl.prototype.toJSON = function () {
        var result = {
            text: this.text,
            typeText: this.typeText,
            icon: this.icon,
            textStyle: this.textStyle,
            children: [],
            key: this.key,
            start: this.start,
            end: this.end,
            selected: this.selected,
            category: this.category
        };
        if (this.children) {
            this.children.forEach(function (child) {
                result.children.push(child.toJSON());
            });
        }
        return result;
    };
    return StructureNodeImpl;
}());
function isStructureNodeImpl(node) {
    return node.getSource != null;
}
function getLabelProvider(node) {
    if (!_labelProviders)
        return null;
    var source = node.getSource();
    if (!source)
        return null;
    return _.find(_labelProviders, function (labelProvider) { return labelProvider.getLabelText(source) != null; });
}
function getDecorator(node) {
    if (!_decorators)
        return null;
    var source = node.getSource();
    if (!source)
        return null;
    return _.find(_decorators, function (decorator) {
        return decorator.getIcon(source) != null || decorator.getTextStyle(source) != null;
    });
}
/**
 * Converts node to a structure node filling its properties. Does not filter or fill children.
 * @param node
 * @returns {any}
 */
function hlNodeToStructureNode(hlNode, selected) {
    if (!hlNode)
        return null;
    var result = new StructureNodeImpl(hlNode);
    var labelProvider = getLabelProvider(result);
    if (labelProvider) {
        result.text = labelProvider.getLabelText(hlNode);
        result.typeText = labelProvider.getTypeText(hlNode);
    }
    var decorator = getDecorator(result);
    if (decorator) {
        result.icon = decorator.getIcon(hlNode);
        result.textStyle = decorator.getTextStyle(hlNode);
    }
    if (_keyProvider) {
        result.key = _keyProvider(hlNode);
    }
    result.start = hlNode.getLowLevelStart();
    result.end = hlNode.getLowLevelEnd();
    if (selected && selected.isSameNode(hlNode))
        result.selected = true;
    return result;
}
function cloneNode(toClone) {
    var result = new StructureNodeImpl(toClone.getSource());
    result.text = toClone.text;
    result.typeText = toClone.typeText;
    result.icon = toClone.icon;
    result.textStyle = toClone.textStyle;
    result.children = toClone.children;
    result.key = toClone.key;
    result.start = toClone.start;
    result.end = toClone.end;
    result.selected = toClone.selected;
    result.category = toClone.category;
    return result;
}
function filterTreeByCategory(root, categoryName) {
    if (!root.children)
        return;
    var result = cloneNode(root);
    var filteredChildren = root.children;
    if (categoryName) {
        var filter = _categoryFilters[categoryName];
        if (filter) {
            filteredChildren =
                _.filter(root.children, function (child) { return filter(child.getSource()); });
            filteredChildren.forEach(function (filteredChild) { return filteredChild.category = categoryName; });
        }
    }
    result.children = filteredChildren;
    return result;
}
function buildTreeRecursively(structureNode, contentProvider) {
    var children = contentProvider(structureNode);
    if (children) {
        structureNode.children = children;
        children.forEach(function (child) { return buildTreeRecursively(child, contentProvider); });
    }
    else {
        structureNode.children = [];
    }
}
var _selected = null;
/**
 * Default implementation of content provider.
 *
 * @param node
 * @returns {Array}
 */
function defaultContentProvider(node) {
    if (node === null) {
        return [];
    }
    var isStructureImpl = isStructureNodeImpl(node);
    if (!isStructureImpl)
        return;
    var source = node.getSource();
    if (source == null)
        return [];
    if (source.isAttr()) {
        return [];
    }
    if (source.isUnknown()) {
        return [];
    }
    var sourceChildren = source.children();
    var filteredSourceChildren = sourceChildren.filter(function (child) { return !child.isAttr() && !child.isUnknown(); });
    var result = [];
    filteredSourceChildren.forEach(function (child) {
        if (_visibilityFilter && !_visibilityFilter(child))
            return;
        var converted = hlNodeToStructureNode(child, _selected);
        if (!converted)
            return;
        result.push(converted);
    });
    return result;
}
/**
 * Gets structure tree for the category. If category is not specified (null), or its
 * filter is not found, returns the whole tree.
 * The root node of the tree always match RAML HL tree root.
 * @param categoryName
 */
function getStructure(categoryName) {
    if (!_astProvider)
        return null;
    var hlRoot = _astProvider.getASTRoot();
    if (!hlRoot)
        return null;
    var _selected = _astProvider.getSelectedNode();
    var structureRoot = hlNodeToStructureNode(hlRoot, _selected);
    if (!structureRoot)
        return null;
    var contentProvider = _contentProvider;
    if (!contentProvider)
        contentProvider = defaultContentProvider;
    buildTreeRecursively(structureRoot, contentProvider);
    var result = filterTreeByCategory(structureRoot, categoryName);
    return result;
}
exports.getStructure = getStructure;
function getStructureForAllCategories() {
    if (!_astProvider)
        return null;
    var hlRoot = _astProvider.getASTRoot();
    if (!hlRoot)
        return null;
    var _selected = _astProvider.getSelectedNode();
    var structureRoot = hlNodeToStructureNode(hlRoot, _selected);
    if (!structureRoot)
        return null;
    var contentProvider = _contentProvider;
    if (!contentProvider)
        contentProvider = defaultContentProvider;
    buildTreeRecursively(structureRoot, contentProvider);
    var result = {};
    for (var categoryName in _categoryFilters) {
        if (_categoryFilters.hasOwnProperty(categoryName)) {
            var filteredTree = filterTreeByCategory(structureRoot, categoryName);
            result[categoryName] = filteredTree;
        }
    }
    return result;
}
exports.getStructureForAllCategories = getStructureForAllCategories;
//# sourceMappingURL=structureImpl.js.map